# Правильное скобочное выражение

[Задача с LeetCode](https://leetcode.com/problems/valid-parentheses/). Уровень сложности: простой.

## Теория
В решении данной задачи нам понаобится такая структура данных, как стек (stack). У стека есть главное правило − FILO (First In Last Out − Первый Вошел Последний Вышел). В стеке есть два основные метода, которые пригодятся при решении данной задачи, − превый это возможность положить что-либо в стек (push), а второй это достать из него последний положенный элемент (pop).

## Описание задачи
Из корректно записанного арифметического выражения, содержащего числа, знаки операций и открывающие и закрывающие скобки '(', '[', '{', выбросим числа и знаки операций, а затем запишем оставшиеся в выражении скобки без пробелов между ними. Полученный результат назовем правильным скобочным выражением. Узнать - валидна ли заданная строка со скобками.

## Обоснование решения
Так как число открывающихся и закрывающихся скобок даже в неправлильной последовательности у нас может быть одинаково и равно N, то считать скобки, чтоб понять является ли строка правильным скобочным выражением, не имеет смысла. 

Попробуем разбить эту задачу на более мелкие подзадачи: предположим, что у нас есть строка вида ’([{ }])’, в таком случае, если мы начнем рассматривать выражение с середины, то сразу заметим, что у нас рядом стоят две скобки открывающая и закрывающая ’{ }’, значит такая микропоследовательность является валидной, раз она является валидной, то в таком случе мы можем просто от нее избавиться и перейти к рассмотрению следующих скобок, при этом наша строка теперь имеет вид: ’([ ])’; легко понять, что с двумя оствавшимися парами скобок мы поступим аналогичным образом, а значит у нас останется пустая строка, то есть незакрытых скобок не осталось; из этого делаем вывод, что строка вида ’([{ }])’ имеет три правильных скобочных выражения.

Для решения данной задачи необходимо рекурсивно пройтись по всем предложенным в строке скобкам и таким образом собрать все пары **[открытая скобка : закрытая скобка]**, а далее сделать вывод относительно валидности заданной строки. При этом необходимо решить задачу, оптимально используя время; в этом случае нам может помочь стек (stack). Об этой структуре данных расказывалось ранее в части теории.

Кратко опишем алгоритм. Будем рассматривать уже использованную ранее строку ’([{ }])’. Будем итерироваться по строке начиная с левой стороны строки и если мы встречае открывающуюся скобку, то мы кладем ее в стек идем дальше, опять встречаем открытую скобку и опять кладем ее в стек, с третьей открытой скобкой делаем аналогичную операцию. Теперь все открывающие скобки закончились, поэтому далее мы встречаем закрытую скобку, но мы не убираем ее в стек, потому что теперь каждый раз когда мы будем встречать закрытую скобку мы будем сравнивать ее с первой скобкой лежащей в нашем стеке, если скобки подходят, то есть
пара имеет вид: **[открытая скобка : закрытая скобка]**, то данное сочетание скобок мы просто откидываем, иначе, если скобки не стыкуются между собой, то мы можем сразу сказать, что пара таких скобок невалидна.
